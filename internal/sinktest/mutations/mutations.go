// Copyright 2023 The Cockroach Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

// Package mutations contains a helper to generate mutations.
package mutations

import (
	"context"
	"encoding/json"
	"fmt"
	"math/rand"
	"time"

	"github.com/cockroachdb/cdc-sink/internal/types"
	"github.com/cockroachdb/cdc-sink/internal/util/hlc"
	"github.com/gofrs/uuid"
)

// Payload instances are generated by a Generator.
type Payload struct {
	PK  uuid.UUID `json:"pk"`
	Ver int       `json:"ver"`
	TS  time.Time `json:"ts"`
}

// Generator returns a channel from which an infinite number of
// mutations can be read. The total number of distinct payload PK value
// is controlled with the idCount argument. The mutations will have
// Payload instances encoded into their Data or Key fields, based on the
// deleteFraction value.
func Generator(ctx context.Context, idCount int, deleteFraction float32) <-chan types.Mutation {
	now := time.Now().UTC().Round(time.Second)
	allPayloads := make([]Payload, idCount)
	for i := range allPayloads {
		allPayloads[i].PK, _ = uuid.NewV4()
		allPayloads[i].TS = now
	}

	muts := make(chan types.Mutation, idCount)
	go func() {
		defer close(muts)

		idx := 0
		for {
			now := time.Now().UTC()
			mut := types.Mutation{Time: hlc.From(now)}

			if rand.Float32() < deleteFraction {
				mut.Key = json.RawMessage(fmt.Sprintf(`["%s"]`, allPayloads[idx].PK))
			} else {
				allPayloads[idx].TS = now
				allPayloads[idx].Ver++

				var err error
				mut.Data, err = json.Marshal(allPayloads[idx])
				if err != nil {
					panic(err)
				}
			}

			select {
			case <-ctx.Done():
				return
			case muts <- mut:
				if idx >= idCount-1 {
					idx = 0
				} else {
					idx++
				}
			}
		}
	}()

	return muts
}
