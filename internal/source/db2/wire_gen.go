// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package db2

import (
	"github.com/cockroachdb/cdc-sink/internal/script"
	"github.com/cockroachdb/cdc-sink/internal/sequencer/chaos"
	"github.com/cockroachdb/cdc-sink/internal/sequencer/immediate"
	script2 "github.com/cockroachdb/cdc-sink/internal/sequencer/script"
	"github.com/cockroachdb/cdc-sink/internal/sinkprod"
	"github.com/cockroachdb/cdc-sink/internal/staging/memo"
	"github.com/cockroachdb/cdc-sink/internal/target/apply"
	"github.com/cockroachdb/cdc-sink/internal/target/dlq"
	"github.com/cockroachdb/cdc-sink/internal/target/schemawatch"
	"github.com/cockroachdb/cdc-sink/internal/util/applycfg"
	"github.com/cockroachdb/cdc-sink/internal/util/diag"
	"github.com/cockroachdb/cdc-sink/internal/util/stopper"
)

// Injectors from injector.go:

// Start creates a DB2 logical replication loop using the
// provided configuration.
func Start(ctx *stopper.Context, config *Config) (*DB2, error) {
	diagnostics := diag.New(ctx)
	configs, err := applycfg.ProvideConfigs(diagnostics)
	if err != nil {
		return nil, err
	}
	scriptConfig := &config.Script
	loader, err := script.ProvideLoader(ctx, configs, scriptConfig, diagnostics)
	if err != nil {
		return nil, err
	}
	eagerConfig, err := ProvideEagerConfig(config, loader)
	if err != nil {
		return nil, err
	}
	targetConfig := &eagerConfig.Target
	targetPool, err := sinkprod.ProvideTargetPool(ctx, targetConfig, diagnostics)
	if err != nil {
		return nil, err
	}
	targetStatements, err := sinkprod.ProvideStatementCache(targetConfig, targetPool, diagnostics)
	if err != nil {
		return nil, err
	}
	dlqConfig := &eagerConfig.DLQ
	watchers, err := schemawatch.ProvideFactory(ctx, targetPool, diagnostics)
	if err != nil {
		return nil, err
	}
	dlQs := dlq.ProvideDLQs(dlqConfig, targetPool, watchers)
	acceptor, err := apply.ProvideAcceptor(ctx, targetStatements, configs, diagnostics, dlQs, targetPool, watchers)
	if err != nil {
		return nil, err
	}
	immediateImmediate := &immediate.Immediate{}
	sequencerConfig := &eagerConfig.Sequencer
	chaosChaos := &chaos.Chaos{
		Config: sequencerConfig,
	}
	stagingConfig := &eagerConfig.Staging
	stagingPool, err := sinkprod.ProvideStagingPool(ctx, stagingConfig, diagnostics, targetConfig)
	if err != nil {
		return nil, err
	}
	stagingSchema, err := sinkprod.ProvideStagingDB(stagingConfig)
	if err != nil {
		return nil, err
	}
	memoMemo, err := memo.ProvideMemo(ctx, stagingPool, stagingSchema)
	if err != nil {
		return nil, err
	}
	sequencer := script2.ProvideSequencer(loader, targetPool, watchers)
	conn, err := ProvideConn(ctx, acceptor, immediateImmediate, chaosChaos, config, memoMemo, sequencer, stagingPool, targetPool, watchers)
	if err != nil {
		return nil, err
	}
	db2 := &DB2{
		Conn:        conn,
		Diagnostics: diagnostics,
	}
	return db2, nil
}
