// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package cdc

import (
	"github.com/cockroachdb/cdc-sink/internal/script"
	"github.com/cockroachdb/cdc-sink/internal/sequencer/besteffort"
	"github.com/cockroachdb/cdc-sink/internal/sequencer/bypass"
	"github.com/cockroachdb/cdc-sink/internal/sequencer/chaos"
	"github.com/cockroachdb/cdc-sink/internal/sequencer/retire"
	script2 "github.com/cockroachdb/cdc-sink/internal/sequencer/script"
	"github.com/cockroachdb/cdc-sink/internal/sequencer/serial"
	"github.com/cockroachdb/cdc-sink/internal/sequencer/shingle"
	"github.com/cockroachdb/cdc-sink/internal/sequencer/switcher"
	"github.com/cockroachdb/cdc-sink/internal/sinktest/all"
	"github.com/cockroachdb/cdc-sink/internal/staging/checkpoint"
	"github.com/cockroachdb/cdc-sink/internal/staging/leases"
	"github.com/cockroachdb/cdc-sink/internal/target/apply"
	"github.com/cockroachdb/cdc-sink/internal/target/dlq"
	"github.com/cockroachdb/cdc-sink/internal/target/schemawatch"
	"github.com/cockroachdb/cdc-sink/internal/util/auth/trust"
	"github.com/cockroachdb/cdc-sink/internal/util/diag"
)

// Injectors from test_fixture.go:

func newTestFixture(fixture *all.Fixture, config *Config) (*testFixture, error) {
	authenticator := trust.New()
	baseFixture := fixture.Fixture
	targetPool := baseFixture.TargetPool
	context := baseFixture.Context
	targetStatements := baseFixture.TargetCache
	configs := fixture.Configs
	diagnostics := diag.New(context)
	dlqConfig := ProvideDLQConfig(config)
	watchers, err := schemawatch.ProvideFactory(context, targetPool, diagnostics)
	if err != nil {
		return nil, err
	}
	dlQs := dlq.ProvideDLQs(dlqConfig, targetPool, watchers)
	acceptor, err := apply.ProvideAcceptor(context, targetStatements, configs, diagnostics, dlQs, targetPool, watchers)
	if err != nil {
		return nil, err
	}
	stagingPool := baseFixture.StagingPool
	stagingSchema := baseFixture.StagingDB
	checkpoints, err := checkpoint.ProvideCheckpoints(context, stagingPool, stagingSchema)
	if err != nil {
		return nil, err
	}
	sequencerConfig := ProvideSequencerConfig(config)
	stagers := fixture.Stagers
	retireRetire := retire.ProvideRetire(sequencerConfig, stagingPool, stagers)
	typesLeases, err := leases.ProvideLeases(context, stagingPool, stagingSchema)
	if err != nil {
		return nil, err
	}
	bestEffort := besteffort.ProvideBestEffort(sequencerConfig, typesLeases, stagingPool, stagers, targetPool, watchers)
	bypassBypass := &bypass.Bypass{}
	chaosChaos := &chaos.Chaos{
		Config: sequencerConfig,
	}
	scriptConfig := ProvideScriptConfig(config)
	loader, err := script.ProvideLoader(configs, scriptConfig, diagnostics)
	if err != nil {
		return nil, err
	}
	sequencer := script2.ProvideSequencer(loader, watchers)
	serialSerial := serial.ProvideSerial(sequencerConfig, typesLeases, stagers, stagingPool, targetPool)
	shingleShingle := shingle.ProvideShingle(sequencerConfig, targetPool)
	switcherSwitcher := switcher.ProvideSequencer(bestEffort, bypassBypass, chaosChaos, diagnostics, sequencer, serialSerial, shingleShingle, stagingPool, targetPool)
	targets, err := ProvideTargets(context, acceptor, config, checkpoints, retireRetire, stagingPool, switcherSwitcher, watchers)
	if err != nil {
		return nil, err
	}
	handler := &Handler{
		Authenticator: authenticator,
		Config:        config,
		TargetPool:    targetPool,
		Targets:       targets,
	}
	cdcTestFixture := &testFixture{
		Fixture: fixture,
		Handler: handler,
		Targets: targets,
	}
	return cdcTestFixture, nil
}

// test_fixture.go:

type testFixture struct {
	*all.Fixture
	Handler *Handler
	Targets *Targets
}
