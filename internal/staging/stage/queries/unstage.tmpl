{{- /*gotype: github.com/cockroachdb/cdc-sink/internal/staging/stage.templateData*/ -}}
{{- $top := . -}}
WITH {{- sp -}}

{{- /*
Start by identifying candidate rows to update.

The starting points for this query are passed as three arrays ($1, $2,
$3) which pass the nanos, logical, and start-after key for the given
staging table.

When the caller provides a limit for the total number of rows requested,
we'll set a scan limit here. In all cases, we'le going to SELECT FOR
UPDATE to give the UPDATE clause at the bottom of the query clear access
to updated the applied column.

candidates_N AS (
SELECT nanos, logical, key, lease
FROM staging_table
WHERE (nanos, logical, key) > ( .... )
AND (nanos, logical) < ($3, $4)
AND NOT applied
[
  ORDER BY nanos, logical, key
  LIMIT N
]
FOR UPDATE
)

*/ -}}
{{- range  $idx, $tgt := .Cursor.Targets -}}
{{- $arrIdx := add $idx 1 -}}
{{- if $idx -}}, {{- nl -}}{{- end -}}
candidates_{{ $idx }} AS (
SELECT nanos, logical, key, lease
FROM {{ $top.StagingTable $tgt }}
WHERE (nanos, logical, key) > (($1::INT8[])[ {{- $arrIdx -}} ], ($2::INT8[])[ {{- $arrIdx -}} ], ($5::STRING[])[ {{- $arrIdx -}} ])
AND (nanos, logical) < ($3, $4)
AND NOT applied
{{- if $top.Cursor.UpdateLimit -}} {{- nl -}}
ORDER BY nanos, logical, key
LIMIT {{ $top.Cursor.UpdateLimit }}
{{- end -}}{{- nl -}}
FOR UPDATE
)
{{- end -}}

{{- /*
Pick the N earliest distinct timestamps.

hlc_all AS (
SELECT nanos, logical FROM (
  SELECT nanos, logical FROM candidates_0 UNION ALL
  SELECT nanos, logical FROM candidates_1 UNION ALL
  ...
  SELECT nanos, logical FROM candidates_N UNION ALL
)
GROUP BY n, l
ORDER BY n, l
LIMIT N -- Set to 1 if TimestampLimit is 0.
)

*/ -}}
, {{- nl -}}
hlc_all AS (
SELECT nanos, logical FROM (
{{- range $idx, $tgt := .Cursor.Targets -}}
{{- if $idx }} UNION ALL {{- nl -}}{{- end -}}
SELECT nanos, logical FROM candidates_{{ $idx }}
{{- end -}}
)
GROUP BY nanos, logical
ORDER BY nanos, logical
LIMIT {{ or $top.Cursor.TimestampLimit 1 }}
)

{{- /*
Optionally identify distinct keys within the candidates with an active
lease that should be ignored. This ensures that if a key at T1 has a
lease, then that key at T2 should not be returned.

blocked_N AS (
SELECT key FROM candidates_N
WHERE (lease IS NOT NULL AND lease > now())
GROUP BY key
)

*/ -}}
{{- if not $.IgnoreLeases -}}
{{- range $idx, $tgt := .Cursor.Targets -}}
, {{- nl -}}
blocked_{{ $idx }} AS (
SELECT key FROM candidates_{{ $idx }}
WHERE (lease IS NOT NULL AND lease > now())
GROUP BY key
)
{{- end -}}
{{- end -}}

{{- /*
Thin the candidate rows using the target timestamp(s) and blocked key(s).

target_N AS (
SELECT * FROM candidates_N c
JOIN hlc_all USING (nanos, logical)
[ WHERE NOT EXISTS (SELECT 1 FROM blocked_N b WHERE b.key = c.key ]
)

*/ -}}
{{- range  $idx, $tgt := .Cursor.Targets -}}
, {{- nl -}}
target_{{ $idx }} AS (
SELECT * FROM candidates_{{ $idx }} c
JOIN hlc_all USING (nanos, logical)
{{- if not $.IgnoreLeases -}}{{- nl -}}
WHERE NOT EXISTS (SELECT 1 FROM blocked_{{ $idx }} b WHERE b.key = c.key)
{{- end -}}
)
{{- end -}}

{{- /*
Set the applied or lease column and return the data.

We want to update any non-applied mutations after the starting key
and within the HLC timestamp(s) that we're operating on.

data_N AS (
UPDATE staging_table s
[
  SET applied=true, lease=NULL
|
  SET lease=( ... )
]
FROM target_N t
WHERE (s.nanos, s.logical, s.key) = (t.nanos, t.logical, t.key)
[
  ORDER BY s.nanos, s.logical, s.key
  LIMIT N
]
RETURNING s.nanos, s.logical, s.key, s.mut, s.before
)
*/ -}}
{{- range $idx, $tgt := .Cursor.Targets -}}
{{- $arrIdx := add $idx 1 -}}
, {{- nl -}}
data_{{ $idx }} AS (
UPDATE {{ $top.StagingTable $tgt }} s {{- nl -}}
{{- if $top.SetApplied -}}
SET applied=true, lease=NULL {{- nl -}}
{{- else if $top.SetLeaseExpiry -}}
{{- /* https://www.cockroachlabs.com/docs/stable/timestamp#convert-an-int-microseconds-since-epoch-to-timestamp */ -}}
SET lease=TIMESTAMP 'epoch' + ({{ $top.SetLeaseExpiry.UnixMilli }}::float / 1000)::INTERVAL {{- nl -}}
{{- end -}}
FROM target_{{ $idx }} t
WHERE (s.nanos, s.logical, s.key) = (t.nanos, t.logical, t.key)
{{- if $top.Cursor.UpdateLimit -}} {{- nl -}}
ORDER BY s.nanos, s.logical, s.key
LIMIT {{ $top.Cursor.UpdateLimit }}
{{- end -}}
{{- nl -}} RETURNING s.nanos, s.logical, s.key, s.mut, s.before
)
{{- end -}}
{{- nl -}}

{{- /*
Top-level query aggregates the updates in table order.

SELECT * FROM (
  SELECT 0 idx, ... FROM data_0 UNION ALL
  SELECT 1 idx, ... FROM data_1 UNION ALL ...
  SELECT N idx, ... FROM data_N
)
ORDER BY nanos, logical, idx, key

*/ -}}
SELECT * FROM ( {{- nl -}}
{{- range $idx, $tgt := .Cursor.Targets -}}
{{- if $idx }} UNION ALL {{- nl -}}{{- end -}}
SELECT {{ $idx }} idx, nanos, logical, key, mut, before FROM data_{{ $idx }}
{{- end -}}
) {{- nl -}}
ORDER BY nanos, logical, idx, key

{{- /* Consume whitespace */ -}}
