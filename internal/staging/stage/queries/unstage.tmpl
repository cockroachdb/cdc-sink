{{- /*gotype: github.com/cockroachdb/cdc-sink/internal/staging/stage.templateData*/ -}}
{{- $top := . -}}
WITH {{- sp -}}

{{- /*
Start by identifying candidate rows to update.
*/ -}}
{{- range  $idx, $tgt := .Cursor.Targets -}}
{{- $arrIdx := add $idx 1 -}}
{{- if $idx -}}, {{- nl -}}{{- end -}}
candidates_{{ $idx }} AS (
SELECT nanos, logical, key, lease
FROM {{ $top.StagingTable $tgt }}
WHERE (nanos, logical, key) > (($1::INT8[])[ {{- $arrIdx -}} ], ($2::INT8[])[ {{- $arrIdx -}} ], ($5::STRING[])[ {{- $arrIdx -}} ])
AND (nanos, logical) < ($3, $4)
AND NOT applied
{{- if $top.Cursor.UpdateLimit -}} {{- nl -}}
ORDER BY nanos, logical, key
LIMIT {{ $top.Cursor.UpdateLimit }}
{{- end -}}{{- nl -}}
FOR UPDATE
)
{{- end -}}

{{- /*
Pick the N earliest distinct timestamps.
*/ -}}
, {{- nl -}}
hlc_all AS (
SELECT nanos n, logical l FROM (
{{- range $idx, $tgt := .Cursor.Targets -}}
{{- if $idx }} UNION ALL {{- nl -}}{{- end -}}
SELECT nanos, logical FROM candidates_{{ $idx }}
{{- end -}}
)
GROUP BY n, l
ORDER BY n, l
LIMIT {{ or $top.Cursor.TimestampLimit 1 }}
)

{{- /*
Identify keys with an active lease that should be ignored. This ensures
that if a key at T1 has a lease, then that key at T2 should not be
returned.
*/ -}}
{{- if not $.IgnoreLeases -}}
{{- range $idx, $tgt := .Cursor.Targets -}}
, {{- nl -}}
blocked_{{ $idx }} AS (
SELECT key FROM candidates_{{ $idx }}
WHERE (lease IS NOT NULL AND lease > now())
GROUP BY key
)
{{- end -}}
{{- end -}}

{{- /*
Thin the candidate rows using the target timestamp(s) and blocked key(s).
*/ -}}
{{- range  $idx, $tgt := .Cursor.Targets -}}
, {{- nl -}}
target_{{ $idx }} AS (
SELECT * FROM candidates_{{ $idx }} c
JOIN hlc_all ON (nanos, logical) = (n, l)
{{- if not $.IgnoreLeases -}}{{- nl -}}
WHERE NOT EXISTS (SELECT 1 FROM blocked_{{ $idx }} b WHERE c.key = b.key)
{{- end -}}
)
{{- end -}}

{{- /*
Set the applied column and return the data.

We want to update any non-applied mutations after the starting key
and within the HLC timestamp(s) that we're operating on.

data_0 AS (
  UPDATE staging_table SET [ (applied=true, lease=NULL) | lease=deadline ]
  FROM hlc_all
  WHERE (nanos, logical) IN (hlc_all)
    AND (nanos, logical, key) > (start_at_nanos, start_at_logical, start_after_key)
    AND NOT applied
    [ AND key NOT IN (SELECT key FROM blocked_0) ]
  [ ORDER BY nanos, logical, key
    LIMIT n ]
  RETURNING nanos, logical, key, mut, before
)
*/ -}}
{{- range $idx, $tgt := .Cursor.Targets -}}
{{- $arrIdx := add $idx 1 -}}
, {{- nl -}}
data_{{ $idx }} AS (
UPDATE {{ $top.StagingTable $tgt }} s {{- nl -}}
{{- if $top.SetApplied -}}
SET applied=true, lease=NULL {{- nl -}}
{{- else if $top.SetLeaseExpiry -}}
{{- /* https://www.cockroachlabs.com/docs/stable/timestamp#convert-an-int-microseconds-since-epoch-to-timestamp */ -}}
SET lease=TIMESTAMP 'epoch' + ({{ $top.SetLeaseExpiry.UnixMilli }}::float / 1000)::INTERVAL {{- nl -}}
{{- end -}}
FROM target_{{ $idx }} t
WHERE (s.nanos, s.logical, s.key) = (t.nanos, t.logical, t.key)
{{- if $top.Cursor.UpdateLimit -}} {{- nl -}}
ORDER BY s.nanos, s.logical, s.key
LIMIT {{ $top.Cursor.UpdateLimit }}
{{- end -}}
{{- nl -}} RETURNING s.nanos, s.logical, s.key, s.mut, s.before)
{{- end -}}
{{- nl -}}

{{- /*
Top-level query aggregates the updates in table order.

SELECT * FROM (
  SELECT 0 idx, ... FROM data_0 UNION ALL
  SELECT 1 idx, ... FROM data_1 UNION ALL ...
  SELECT N idx, ... FROM data_N
)
ORDER BY nanos, logical, idx, key

*/ -}}
SELECT * FROM ( {{- nl -}}
{{- range $idx, $tgt := .Cursor.Targets -}}
{{- if $idx }} UNION ALL {{- nl -}}{{- end -}}
SELECT {{ $idx }} idx, nanos, logical, key, mut, before FROM data_{{ $idx }}
{{- end -}}
) {{- nl -}}
ORDER BY nanos, logical, idx, key

{{- /* Consume whitespace */ -}}
